!  This file is part of XOPTFOIL.

!  XOPTFOIL is free software: you can redistribute it and/or modify
!  it under the terms of the GNU General Public License as published by
!  the Free Software Foundation, either version 3 of the License, or
!  (at your option) any later version.

!  XOPTFOIL is distributed in the hope that it will be useful,
!  but WITHOUT ANY WARRANTY; without even the implied warranty of
!  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!  GNU General Public License for more details.

!  You should have received a copy of the GNU General Public License
!  along with XOPTFOIL.  If not, see <http://www.gnu.org/licenses/>.

!  Copyright (C) 2017-2019 Daniel Prosser

module input_output

! Module with subroutines for reading and writing of files

  use os_util

  implicit none

  contains


  subroutine read_inputs(input_file, global_search,                            &
                       seed_airfoil, airfoil_file,                             &
                       nfunctions_top, nfunctions_bot,                         &
                       pso_options, ga_options, matchfoil_file, symmetrical)
!! read the input file with all the parameters
!     - first checks of params (see also check_inputs) 

  use vardef
  use airfoil_evaluation
  use particle_swarm,       only : pso_options_type
  use genetic_algorithm,    only : ga_options_type
  use simplex_search,       only : ds_options_type
  use xfoil_driver,         only : xfoil_geom_options_type
  use math_deps,            only : sort_vector
  use airfoil_shape_bezier, only : bezier_spec_type, ndv_to_ncp, ncp_to_ndv

  character(*), intent(in)   :: input_file 
  character(80), intent(out) :: global_search, seed_airfoil, airfoil_file, matchfoil_file
  integer, intent(out) :: nfunctions_top, nfunctions_bot
  logical, intent(out) :: symmetrical
  type(pso_options_type), intent(out) :: pso_options
  type(ga_options_type),  intent(out) :: ga_options


  type(bezier_spec_type) :: bezier_spec
  integer, dimension(max_addthickconst) :: sort_idxs
  double precision, dimension(max_addthickconst) :: temp_thickmin, temp_thickmax
  logical :: feasible_init, repanel
  integer :: pso_pop, pso_maxit, simplex_maxit, npan, feasible_init_attempts
  integer :: ga_pop, ga_maxit
  double precision :: pso_tol, simplex_tol
  double precision :: cvpar, cterat, ctrrat, xsref1, xsref2, xpref1, xpref2
  double precision :: feasible_limit
  double precision :: ga_tol, parent_fraction, roulette_selection_pressure,    &
                      tournament_fraction, crossover_range_factor,             &
                      mutant_probability, chromosome_mutation_rate,            &
                      mutation_range_factor
  integer       :: i, iunit, ioerr, iostat1
  type(re_type) :: re_default
  character(30) :: text
  character(20) :: pso_convergence_profile
  character(10) :: parents_selection_method

  ! Geo targets 
  double precision :: sum_weightings
  double precision, dimension(max_geo_targets) :: x_pos, target_geo
  double precision, dimension(max_geo_targets) :: weighting_geo
  character(30), dimension(max_geo_targets) :: target_type
  integer :: ngeo_targets

  ! #depricated compatibility to Xoptfoil
  integer :: max_curv_reverse_top, max_curv_reverse_bot
  double precision :: curv_threshold

  ! show/suppress extensive echo of input parms
  logical :: echo_input_parms
  
  namelist /optimization_options/ global_search,                               &
            seed_airfoil, airfoil_file, shape_functions, nfunctions_top,       &
            nfunctions_bot, initial_perturb, min_bump_width,                   &
            show_details, echo_input_parms

  namelist /constraints/ min_thickness, max_thickness, moment_constraint_type, &
                         min_moment, min_te_angle,                             &
                         check_geometry,                                       &
                         max_curv_reverse_top, max_curv_reverse_bot,           &
                         curv_threshold, symmetrical, min_flap_degrees,        &
                         max_flap_degrees, min_camber, max_camber,             &
                         naddthickconst, addthick_x, addthick_min, addthick_max
  namelist /initialization/ feasible_init, feasible_limit,                     &
                            feasible_init_attempts
  namelist /particle_swarm_options/ pso_pop, pso_tol, pso_maxit,               &
                                    pso_convergence_profile,                   &
                                    pso_options       ! allow direct manipulation
  namelist /genetic_algorithm_options/ ga_pop, ga_tol, ga_maxit,               &
            parents_selection_method, parent_fraction,                         &
            roulette_selection_pressure, tournament_fraction,                  &
            crossover_range_factor, mutant_probability,                        &
            chromosome_mutation_rate, mutation_range_factor
  namelist /simplex_options/ simplex_tol, simplex_maxit
  namelist /xfoil_paneling_options/ npan, cvpar, cterat, ctrrat, xsref1,       &
            xsref2, xpref1, xpref2, repanel
  namelist /matchfoil_options/ match_foils, matchfoil_file
  namelist /geometry_targets/ ngeo_targets, target_type, x_pos, target_geo,  &
            weighting_geo 


! Open input file

  iunit = 12
  open(unit=iunit, file=input_file, status='old', iostat=ioerr)
  if (ioerr /= 0)                                                              &
    call my_stop('Could not find input file '//trim(input_file)//'.')

! Set defaults for main namelist options

  global_search = 'particle_swarm'
  seed_airfoil = 'from_file'
  airfoil_file = ''
  shape_functions = 'hicks-henne'
  min_bump_width = 0.1d0
  nfunctions_top = 4
  nfunctions_bot = 4
  initial_perturb = 0.003d0

! Show more infos  / supress echo
  show_details = .false. 
  echo_input_parms = .false.
 
! Read main namelist options

  rewind(iunit)
  read(iunit, iostat=iostat1, nml=optimization_options)
  call namelist_check('optimization_options', iostat1, 'warn')

! In case of 'camb-thick' set number of top functions to a fixed number of 6
  if (trim(shape_functions) == 'camb-thick' ) then
    nfunctions_top = 6
    nfunctions_bot = 0
! In case of 'camb-thick-plus' set number of top functions to a fixed number of 12    
  else if (trim(shape_functions) == 'camb-thick-plus' ) then
    nfunctions_top = 12
    nfunctions_bot = 0
  end if

! Read bezier options 

  if (trim(shape_functions) == 'bezier' ) then
    
    call read_bezier_inputs  ('', iunit, bezier_spec)
 
    ! take bezier control point x and y as 'function' 
    ! - LE, TE are fixed, 2nd point only vertical movement   
    nfunctions_top = ncp_to_ndv (bezier_spec%ncpoints_top)
    nfunctions_bot = ncp_to_ndv (bezier_spec%ncpoints_bot)

  end if 

! Optional seed airfoil file from command file 

  airfoil_file = read_cl_airfoil_file (airfoil_file)


! Option to match seed airfoil to another instead of aerodynamic optimization

  match_foils = .false.
  matchfoil_file = 'none'
  rewind(iunit)
  read(iunit, iostat=iostat1, nml=matchfoil_options)


! Read operating conditions

  if (.not. match_foils) then

    call read_op_points_spec('', iunit, noppoint, re_default, &
                             flap_spec, flap_degrees, flap_selection, &
                             op_points_spec, dynamic_weighting_spec)
  else 
     noppoint = 0
  end if

  nflap_optimize = 0
  if (flap_spec%use_flap .and. (.not. match_foils)) then
    do i = 1, noppoint
      if (flap_selection(i) == 'optimize') then
        nflap_optimize = nflap_optimize + 1
        flap_optimize_points(nflap_optimize) = i
      end if
    end do
  end if


! Geo targets - start read and weight options---------------------

  ngeo_targets = 0
  target_type (:) = ''
  x_pos(:) = 0.d0                                     ! #depricated
  target_geo(:) = 0.d0 
  weighting_geo(:) = 1d0 

  rewind(iunit)
  read(iunit, iostat=iostat1, nml=geometry_targets)
  call namelist_check('geometry_targets', iostat1, 'no-warn')

  allocate (geo_targets(ngeo_targets)) 

  geo_targets%reference_value   = 0.d0
  geo_targets%dynamic_weighting = .false.

  do i = 1, ngeo_targets
    geo_targets(i)%type           = target_type(i)
    geo_targets(i)%target_value   = target_geo(i)
    geo_targets(i)%weighting      = weighting_geo(i)
    geo_targets(i)%weighting_user = weighting_geo(i)
    if (dynamic_weighting_spec%active) then     ! #todo op_specs must be before geo in input file
    ! Set geo targets to dynamic if weighting is positive
      if (geo_targets(i)%weighting_user < 0d0) then
      ! no dynamic if user defined explizit weighting
        geo_targets(i)%weighting_user = - geo_targets(i)%weighting_user
      else
        geo_targets(i)%dynamic_weighting = .true.
      end if 
    end if 
    if (x_pos(i) /= 0d0) & 
      call my_stop ("Target_type 'zBot', 'zTop' and the parameter x_pos are depricated ",'warn')
  end do   

  
! Modify normalize weightings for operating points
!          now includis geo targets  
  if (noppoint > 0) then

      sum_weightings = sum(op_points_spec%weighting_user)               &
                     + sum(geo_targets%weighting_user)

    if (sum_weightings > 0d0) then 
      op_points_spec%weighting = op_points_spec%weighting_user / sum_weightings
      geo_targets%weighting    = geo_targets%weighting         / sum_weightings
    else
      op_points_spec%weighting = 0d0
      geo_targets%weighting    = 0d0
    end if
  end if 
  

! Read curvature constraints

  call read_curvature_constraints_inputs ('', iunit, curv_spec, curv_top_spec, curv_bot_spec)


! Curvature compatibility to Xoptfoil

  curv_threshold       = curv_top_spec%curv_threshold
  max_curv_reverse_top = curv_top_spec%max_curv_reverse
  max_curv_reverse_bot = curv_bot_spec%max_curv_reverse

! Read constraints

  check_geometry = .true.
  min_thickness = 0.01d0
  max_thickness = 1000.d0
  min_camber = -0.1d0
  max_camber = 0.1d0
  moment_constraint_type(:) = 'none'
  min_moment(:) = -1.d0
  min_te_angle = 2.d0

  symmetrical = .false.
  min_flap_degrees = -5.d0
  max_flap_degrees = 15.d0
  naddthickconst = 0
  addthick_x(:) = 0.01d0
  addthick_min(:) = -1000.d0
  addthick_max(:) = 1000.d0

  rewind(iunit)
  read(iunit, iostat=iostat1, nml=constraints)

  call namelist_check('constraints', iostat1, 'no-warn')    ! No warning if no constraints

  ! Sort thickness constraints in ascending x/c order
  if (naddthickconst > 0) then
    call sort_vector(addthick_x(1:naddthickconst), sort_idxs(1:naddthickconst))
    temp_thickmin = addthick_min
    temp_thickmax = addthick_max
    do i = 1, naddthickconst
      addthick_min(i) = temp_thickmin(sort_idxs(i))
      addthick_max(i) = temp_thickmax(sort_idxs(i))
    end do
  end if

! Curvature compatibility to Xoptfoil

  curv_top_spec%curv_threshold   = curv_threshold
  curv_top_spec%max_curv_reverse = max_curv_reverse_top
  curv_bot_spec%max_curv_reverse = max_curv_reverse_bot  


! Set default initialization options

  feasible_init = .true. 
  feasible_limit = 5.0D+04
  feasible_init_attempts = 1000

! Read initialization parameters

  rewind(iunit)
  read(iunit, iostat=iostat1, nml=initialization)
  call namelist_check('initialization', iostat1, 'no-warn')

! Set default particle swarm options

  pso_pop = 40
  pso_tol = 1.D-04
  pso_maxit = 600

  if ((trim(shape_functions) == 'camb-thick' ) .or. &
      (trim(shape_functions) == 'camb-thick-plus')) then
    pso_convergence_profile = 'quick_camb_thick'
  else
    pso_convergence_profile = 'exhaustive'
  end if

! Set default genetic algorithm options

  ga_pop = 80
  ga_tol = 1.D-04
  ga_maxit = 700
  parents_selection_method = 'tournament'
  parent_fraction = 0.5d0
  roulette_selection_pressure = 8.d0
  tournament_fraction = 0.025d0
  crossover_range_factor = 0.5d0
  mutant_probability = 0.4d0
  chromosome_mutation_rate = 0.01d0
  mutation_range_factor = 0.2d0

! Set default simplex search options

  simplex_tol = 1.0D-05
  simplex_maxit = 1000




  if (trim(global_search) == 'particle_swarm') then

  ! Read PSO options and put them into derived type

    rewind(iunit)
    read(iunit, iostat=iostat1, nml=particle_swarm_options)
    call namelist_check('particle_swarm_options', iostat1, 'no-warn')
    pso_options%pop = pso_pop
    pso_options%tol = pso_tol
    pso_options%maxspeed = initial_perturb
    pso_options%maxit = pso_maxit
    pso_options%convergence_profile = pso_convergence_profile

    pso_options%feasible_init = feasible_init
    pso_options%feasible_limit = feasible_limit
    pso_options%feasible_init_attempts = feasible_init_attempts

  else if (trim(global_search) == 'genetic_algorithm') then

  ! Read genetic algorithm options and put them into derived type

    rewind(iunit)
    read(iunit, iostat=iostat1, nml=genetic_algorithm_options)
    call namelist_check('genetic_algorithm_options', iostat1, 'warn')
    ga_options%pop = ga_pop
    ga_options%tol = ga_tol
    ga_options%maxit = ga_maxit
    ga_options%parents_selection_method = parents_selection_method
    ga_options%parent_fraction = parent_fraction
    ga_options%roulette_selection_pressure = roulette_selection_pressure
    ga_options%tournament_fraction = tournament_fraction
    ga_options%crossover_range_factor = crossover_range_factor
    ga_options%mutant_probability = mutant_probability
    ga_options%chromosome_mutation_rate = chromosome_mutation_rate
    ga_options%mutation_range_factor = mutation_range_factor
    ga_options%feasible_init = feasible_init
    ga_options%feasible_limit = feasible_limit
    ga_options%feasible_init_attempts = feasible_init_attempts

  else
    call my_stop("Global search type '"//trim(global_search)//               &
                  "' is not available.")
  end if


! Read and set default xfoil run options

  call  read_xfoil_options_inputs  ('', iunit, xfoil_options)

! Set default xfoil  paneling options

  call read_xfoil_paneling_inputs  ('', iunit, xfoil_geom_options)

! Close the input file

  close(iunit)

! Echo namelist options for checking purposes

  if (.not. match_foils .and. show_details) then 
    call echo_op_points_spec  (op_points_spec, xfoil_options) 
  end  if



! jx-mod  (I did it ... ;-) )
  if (.not. echo_input_parms) goto 10000

  write(*,*)
  write(*,*) 'Echoing program options:'
  write(*,*)

! Optimization options namelist

  write(*,'(A)') " &optimization_options"
  write(*,*) " global_search = '"//trim(global_search)//"'"
  write(*,*) " seed_airfoil = '"//trim(seed_airfoil)//"'"
  write(*,*) " airfoil_file = '"//trim(airfoil_file)//"'"
  write(*,*) " shape_functions = '"//trim(shape_functions)//"'"
  write(*,*) " min_bump_width = ", min_bump_width
  write(*,*) " nfunctions_top = ", nfunctions_top
  write(*,*) " nfunctions_bot = ", nfunctions_bot
  write(*,*) " initial_perturb = ", initial_perturb
  write(*,*) " show_details = ", show_details
  write(*,*) " echo_input_parms = ", echo_input_parms 

  write(*,'(A)') " /"
  write(*,*)

! Operating conditions namelist

  write(*,'(A)') " &operating_conditions"
  write(*,*)
  write(*,*) " use_flap = ", flap_spec%use_flap
  write(*,*) " x_flap = ", flap_spec%x_flap
  write(*,*) " y_flap = ", flap_spec%y_flap
  write(*,*) " y_flap_spec = "//trim(flap_spec%y_flap_spec)
  write(*,*)

  write(*,*)

! Curvature namelist

  write(*,*) " do_smoothing = ", curv_spec%do_smoothing
  write(*,*) " check_curvature = ", curv_spec%check_curvature
  write(*,*) " auto_curvature = ", curv_spec%auto_curvature
  write(*,*) " max_curv_reverse_top = ", curv_top_spec%max_curv_reverse
  write(*,*) " max_curv_reverse_bot = ", curv_bot_spec%max_curv_reverse
  write(*,*) " curv_threshold = ",  curv_top_spec%curv_threshold
  write(*,*) " spike_threshold = ", curv_top_spec%spike_threshold
  write(*,*) " max_te_curvature = ", curv_top_spec%max_te_curvature

  ! Constraints namelist

  write(*,'(A)') " &constraints"
  write(*,*) " min_thickness = ", min_thickness
  write(*,*) " max_thickness = ", max_thickness
  write(*,*) " min_te_angle = ", min_te_angle
  write(*,*) " symmetrical = ", symmetrical
  write(*,*) " min_flap_degrees = ", min_flap_degrees
  write(*,*) " max_flap_degrees = ", max_flap_degrees
  write(*,*) " min_camber = ", min_camber
  write(*,*) " max_camber = ", max_camber
  write(*,*) " naddthickconst = ", naddthickconst
  do i = 1, naddthickconst
    write(text,*) i
    text = adjustl(text)
    write(*,*) " addthick_x("//trim(text)//") = ", addthick_x(i)
    write(*,*) " addthick_min("//trim(text)//") = ", addthick_min(i)
    write(*,*) " addthick_max("//trim(text)//") = ", addthick_max(i)
  end do
  write(*,'(A)') " /"
  write(*,*)

! Geo targets - echo namelist

  write(*,'(A)') " &geometry_targets"

  do i = 1, ngeo_targets
    write(text,*) i
    text = adjustl(text)
    write(*,*) " target_type("//trim(text)//") = ",   geo_targets(i)%type
    write(*,*) " target_value("//trim(text)//") = ",  geo_targets(i)%target_value
    write(*,*) " weighting_geo("//trim(text)//") = ", geo_targets(i)%weighting
    if (i < noppoint) write(*,*)
  end do   
  write(*,'(A)') " /"
  write(*,*)


! Initialization namelist

  write(*,'(A)') " &initialization"
  write(*,*) " feasible_init = ", feasible_init
  write(*,*) " feasible_limit = ", feasible_limit
  write(*,*) " feasible_init_attempts = ", feasible_init_attempts
  write(*,'(A)') " /"
  write(*,*)

! Optimizer namelists


  if (trim(global_search) == 'particle_swarm') then

!     Particle swarm namelist

    write(*,'(A)') " &particle_swarm_options"
    write(*,*) " pso_pop = ", pso_options%pop
    write(*,*) " pso_tol = ", pso_options%tol
    write(*,*) " pso_maxit = ", pso_options%maxit
    write(*,*) " pso_convergence_profile = ", pso_options%convergence_profile
    write(*,'(A)') " /"
    write(*,*)

  else if (trim(global_search) == 'genetic_algorithm') then

!     Genetic algorithm options

    write(*,'(A)') " &genetic_algorithm_options"
    write(*,*) " ga_pop = ", ga_options%pop
    write(*,*) " ga_tol = ", ga_options%tol
    write(*,*) " ga_maxit = ", ga_options%maxit
    write(*,*) " parents_selection_method = ",                               &
                ga_options%parents_selection_method
    write(*,*) " parent_fraction = ", ga_options%parent_fraction 
    write(*,*) " roulette_selection_pressure = ",                            &
                ga_options%roulette_selection_pressure
    write(*,*) " tournament_fraction = " , ga_options%tournament_fraction
    write(*,*) " crossover_range_factor = ", ga_options%crossover_range_factor
    write(*,*) " mutant_probability = ", ga_options%mutant_probability
    write(*,*) " chromosome_mutation_rate = ",                               &
                ga_options%chromosome_mutation_rate
    write(*,*) " mutation_range_factor = ", ga_options%mutation_range_factor
    write(*,'(A)') " /"
    write(*,*)

  end if


! Xfoil paneling options namelist

  write(*,'(A)') " &xfoil_paneling_options"
  write(*,*) " npan = ", xfoil_geom_options%npan
  write(*,*) " cvpar = ", xfoil_geom_options%cvpar
  write(*,*) " cterat = ", xfoil_geom_options%cterat
  write(*,*) " ctrrat = ", xfoil_geom_options%ctrrat
  write(*,*) " xsref1 = ", xfoil_geom_options%xsref1
  write(*,*) " xsref2 = ", xfoil_geom_options%xsref2
  write(*,*) " xpref1 = ", xfoil_geom_options%xpref1
  write(*,*) " xpref2 = ", xfoil_geom_options%xpref2
  write(*,'(A)') " /"
  write(*,*)

! Matchfoil options

  write(*,'(A)') " &matchfoil_options"
  write(*,*) " match_foils = ", match_foils
  write(*,*) " matchfoil_file = '"//trim(matchfoil_file)//"'"
  write(*,'(A)') " /"
  write(*,*)


! jx-mod  (I did it ... ;-)
  10000 continue


! Check that inputs are reasonable

! Optimization settings

  if (trim(seed_airfoil) /= 'from_file' .and.                                  &
      trim(seed_airfoil) /= 'from_bezier' )                                    &
    call my_stop("seed_airfoil must be 'from_file' or 'from_bezier'.")
  if (trim(shape_functions) /= 'hicks-henne' .and.                             &
      trim(shape_functions) /= 'bezier' .and.                                  &
      trim(shape_functions) /= 'camb-thick' .and.                              &
      trim(shape_functions) /= 'camb-thick-plus')                              &
    call my_stop("shape_functions must be 'hicks-henne', 'bezier',"//          &
                 "'camb-thick' or 'camb-thick-plus'.")
  if ((nfunctions_top < 0) .and.   & 
      trim(shape_functions) /= 'camb-thick' .and.                              &
      trim(shape_functions) /= 'camb-thick-plus')                              &
    call my_stop("nfunctions_top must be >= 0.")
  if ((nfunctions_bot < 0) .and. &
       trim(shape_functions) /= 'camb-thick' .and.                             &
       trim(shape_functions) /= 'camb-thick-plus')                             &
    call my_stop("nfunctions_bot must be >= 0.")
  if (initial_perturb <= 0.d0)                                                 &
    call my_stop("initial_perturb must be > 0.")
  if ((min_bump_width <= 0.d0) .and.                                           &
      trim(shape_functions) /= 'bezier' .and.                                  &
      trim(shape_functions) /= 'camb-thick' .and.                              &
      trim(shape_functions) /= 'camb-thick-plus')                              &
    call my_stop("min_bump_width must be > 0.")

! Constraints

  if (curv_spec%check_curvature ) then 
    if (curv_top_spec%curv_threshold   < 0.01d0)  call my_stop("curv_threshold must be >= 0.01")
    if (curv_top_spec%spike_threshold  < 0.01d0 ) call my_stop ("spike_threshold must be >= 0.01")
    if (curv_top_spec%max_curv_reverse < 0)  call my_stop("max_curv_reverse_top must be >= 0")
    if (curv_bot_spec%max_curv_reverse < 0)  call my_stop("max_curv_reverse_bot must be >= 0")
    if (curv_top_spec%max_te_curvature < 0.d0) call my_stop("max_te_curvature must be >= 0")
  end if 

  if (min_thickness <= 0.d0) call my_stop("min_thickness must be > 0.")
  if (max_thickness <= 0.d0) call my_stop("max_thickness must be > 0.")
  if (min_thickness >= max_thickness)                                          &
    call my_stop("min_thickness must be < max_thickness.")
  do i = 1, noppoint
    if (trim(moment_constraint_type(i)) /=  'none')                               &
      call my_stop("Moment constraints are no more supported in Xoptfoil-JX. "//  &
                    "Please use target-moment instead")
  end do
  if (min_te_angle < 0.d0) call my_stop("min_te_angle must be >= 0.")
  if (symmetrical)                                                             &
    call print_note ("Mirroring top half of seed airfoil for symmetrical constraint.")
  if (min_flap_degrees >= max_flap_degrees)                                    &
    call my_stop("min_flap_degrees must be < max_flap_degrees.")
  if (min_flap_degrees <= -90.d0)                                              &
    call my_stop("min_flap_degrees must be > -90.")
  if (max_flap_degrees >= 90.d0)                                               &
    call my_stop("max_flap_degrees must be < 90.")
  if (min_camber >= max_camber)                                                &
    call my_stop("min_camber must be < max_camber.")
  
  if (naddthickconst > max_addthickconst) then
     write(text,*) max_addthickconst
     text = adjustl(text)
     call my_stop("naddthickconst must be <= "//trim(text)//".")
  end if
  do i = 1, naddthickconst
    if (addthick_x(i) <= 0.d0) call my_stop("addthick_x must be > 0.")
    if (addthick_x(i) >= 1.d0) call my_stop("addthick_x must be < 1.")
    if (addthick_min(i) >= addthick_max(i))                                    &
      call my_stop("addthick_min must be < addthick_max.")
  end do


! Geo targets - check options

  do i = 1, ngeo_targets
    if ((trim(geo_targets(i)%type) /= 'Camber') .and.                          &
      trim(geo_targets(i)%type) /= 'Thickness')                                &
      call my_stop("Target_type must be 'Camber' or 'Thickness'.")
  end do   


! Initialization options
    
  if ((feasible_limit <= 0.d0) .and. feasible_init)                            &
    call my_stop("feasible_limit must be > 0.")
  if ((feasible_init_attempts < 1) .and. feasible_init)                        &
    call my_stop("feasible_init_attempts must be > 0.")

! Optimizer options

  if (trim(global_search) == 'particle_swarm') then

    if (pso_pop < 1) call my_stop("pso_pop must be > 0.")
    if (pso_tol <= 0.d0) call my_stop("pso_tol must be > 0.")
    if (pso_maxit < 1) call my_stop("pso_maxit must be > 0.")  
    if ( (trim(pso_convergence_profile) /= "quick") .and.                    &
          (trim(pso_convergence_profile) /= "exhaustive") .and.               &
          (trim(pso_convergence_profile) /= "quick_camb_thick"))                       &
      call my_stop("pso_convergence_profile must be 'exhaustive' "//&
                    "or 'quick' or 'quick_camb_thick'.")

  else if (trim(global_search) == 'genetic_algorithm') then

    if (ga_pop < 1) call my_stop("ga_pop must be > 0.")
    if (ga_tol <= 0.d0) call my_stop("ga_tol must be > 0.")
    if (ga_maxit < 1) call my_stop("ga_maxit must be > 0.")
    if ( (trim(parents_selection_method) /= "roulette") .and.                &
          (trim(parents_selection_method) /= "tournament") .and.              &
          (trim(parents_selection_method) /= "random") )                      &
      call my_stop("parents_selection_method must be 'roulette', "//&
                    "'tournament', or 'random'.")
    if ( (parent_fraction <= 0.d0) .or. (parent_fraction > 1.d0) )           &
      call my_stop("parent_fraction must be > 0 and <= 1.")
    if (roulette_selection_pressure <= 0.d0)                                 &
      call my_stop("roulette_selection_pressure must be > 0.")
    if ( (tournament_fraction <= 0.d0) .or. (tournament_fraction > 1.d0) )   &
      call my_stop("tournament_fraction must be > 0 and <= 1.")
    if (crossover_range_factor < 0.d0)                                       &
      call my_stop("crossover_range_factor must be >= 0.")
    if ( (mutant_probability < 0.d0) .or. (mutant_probability > 1.d0) )      &
      call my_stop("mutant_probability must be >= 0 and <= 1.") 
    if (chromosome_mutation_rate < 0.d0)                                     &
      call my_stop("chromosome_mutation_rate must be >= 0.")
    if (mutation_range_factor < 0.d0)                                        &
      call my_stop("mutation_range_factor must be >= 0.")

  end if
  
end subroutine read_inputs



!=============================================================================
! Read operating points specification from input file 
!   (separated from read_inputs to be more modular)
!=============================================================================

subroutine read_op_points_spec  (input_file, or_iunit, noppoint, re_def, &
                                 flap_spec, flap_degrees, flap_selection, &
                                 op_points_spec, dynamic_weighting_spec)

  use xfoil_driver,       only : op_point_specification_type, re_type
  use airfoil_evaluation, only : dynamic_weighting_specification_type
  use vardef,             only : max_op_points, flap_spec_type

  character(*), intent(in)    :: input_file 
  integer, intent(in)         :: or_iunit
  integer, intent(out)        :: noppoint
  type (re_type), intent(out) :: re_def

  type(flap_spec_type), intent(out) :: flap_spec
  double precision, dimension(:), intent(inout) :: flap_degrees
  character(8),     dimension(:), intent(inout) :: flap_selection

  type(op_point_specification_type), dimension(:), allocatable, intent(out)  :: op_points_spec
  type(dynamic_weighting_specification_type), intent(out) :: dynamic_weighting_spec


! Op_point specification 
  character(7),     dimension(max_op_points)  :: op_mode
  character(15),    dimension(max_op_points)  :: optimization_type
  double precision, dimension(max_op_points)  :: op_point, weighting, &
                                                 ncrit_pt, target_value, reynolds, mach

  double precision      :: re_default
  logical               :: re_default_as_resqrtcl, dynamic_weighting
  logical               :: allow_improved_target
  type(op_point_specification_type) :: op

  integer               :: i, iunit, ioerr, iostat1
  character(10)         :: text

  double precision      :: x_flap, y_flap
  character(3)          :: y_flap_spec
  logical               :: use_flap


  namelist /operating_conditions/ noppoint, op_mode, op_point, reynolds, mach,   &
            target_value, weighting, optimization_type, ncrit_pt,                & 
            re_default_as_resqrtcl, re_default, dynamic_weighting, dynamic_weighting_spec, &
            use_flap, x_flap, y_flap, y_flap_spec, flap_degrees, flap_selection, &
            allow_improved_target

  ! Set defaults for operating conditions and constraints

  noppoint = 0

  re_default = 100000d0
  re_default_as_resqrtcl = .false.
  reynolds(:) = -1.d0                         ! value in input file

  op_mode(:) = 'spec-cl'
  op_point(:) = 0.d0
  optimization_type(:) = 'min-drag'
  mach(:) = 0.d0
  weighting(:) = 1.d0
  ncrit_pt(:) = -1.d0
  target_value(:) = 0 

  use_flap     = .false.                
  x_flap       = 0.75d0
  y_flap       = 0.d0
  y_flap_spec  = 'y/c'
  flap_degrees      = 0d0
  flap_selection    = 'specify'

  allow_improved_target = .false.

  ! Default values controlling dynamic weighting 
  dynamic_weighting = .false. 
  dynamic_weighting_spec%min_weighting = 0.6d0 
  dynamic_weighting_spec%max_weighting = 1.4d0 
  dynamic_weighting_spec%extra_punch   = 1.2d0 
  dynamic_weighting_spec%start_with_design = 10
  dynamic_weighting_spec%frequency = 20


! (Open input file) , read options

  if (trim(input_file) == '') then
    iunit = or_iunit
    rewind(iunit)
    read(iunit, iostat=iostat1, nml=operating_conditions)
  else
    iunit = 12
    open(unit=iunit, file=input_file, status='old', iostat=ioerr)
    if (ioerr /= 0) call my_stop('Could not find input file '//trim(input_file)//'.')
    read(iunit, iostat=iostat1, nml=operating_conditions)
    close(iunit)
  end if

  call namelist_check('operating_conditions', iostat1, 'warn')

! overwrite re_default if specified in command line 

  re_default = read_cl_re_default ((re_default))
  re_def%number = read_cl_re_default ((re_default))
  if (re_default_as_resqrtcl) then
    re_def%type = 2
  else
    re_def%type = 1
  end if


! store op_point specification in data structure ------------------------

  allocate (op_points_spec(noppoint)) 

  do i = 1, noppoint
    op_points_spec(i)%spec_cl = (op_mode(i) == 'spec-cl')
    op_points_spec(i)%value   = op_point(i)
    
    op_points_spec(i)%ncrit = ncrit_pt(i)    
    op_points_spec(i)%optimization_type = optimization_type (i)
    op_points_spec(i)%target_value = target_value (i)
    op_points_spec(i)%allow_improved_target = allow_improved_target
    
    if (reynolds(i) /= -1.d0) then
      op_points_spec(i)%re%number  = reynolds(i)
      op_points_spec(i)%re%type    = 1
    else                                    ! take default Re number
      op_points_spec(i)%re = re_def 
    end if
    op_points_spec(i)%ma%number  = mach(i)   ! mach number only Type 1
    op_points_spec(i)%ma%type    = 1

    op_points_spec(i)%weighting_user  = weighting (i)
  end do 

! Dynamic weighting - if activated all op_points with 'target' will be dynamic 

  dynamic_weighting_spec%active = dynamic_weighting
  op_points_spec%extra_punch       = .false. 
  op_points_spec%dynamic_weighting = .false.      

  ! Set op points to dynamic if weighting is positive
  do i= 1, noppoint
    if (trim(op_points_spec(i)%optimization_type (1:6)) == 'target') then
      if (op_points_spec(i)%weighting_user < 0d0) then
        ! switch off dynamic if user defined explizit weighting
        op_points_spec(i)%dynamic_weighting = .false.
        op_points_spec(i)%weighting_user = - op_points_spec(i)%weighting_user
      else
        if (dynamic_weighting_spec%active) &
          op_points_spec(i)%dynamic_weighting = .true.
      end if 
    end if
  end do

  if (.not. any(op_points_spec%dynamic_weighting)) dynamic_weighting_spec%active = .false.

!  Modify normalize weightings for operating points
!  ... will be re-normalized if there are geo_targets...!
  op_points_spec%weighting    = op_points_spec%weighting_user / sum(op_points_spec%weighting_user)
  op_points_spec%scale_factor = 1d0

! Flap settings to final data structure

  flap_spec%use_flap    = use_flap
  flap_spec%x_flap      = x_flap
  flap_spec%y_flap      = y_flap
  flap_spec%y_flap_spec = y_flap_spec

! Check input data  ------------------------

  if (noppoint < 1) call my_stop("noppoint must be > 0")
  if (noppoint > max_op_points) then
     write(text,'(I5)') max_op_points
     text = adjustl(text)
     call my_stop("noppoints must be <= "//trim(text)//".")
  end if

  if ((use_flap) .and. (x_flap <= 0.0)) call my_stop("x_flap must be > 0.")
  if ((use_flap) .and. (x_flap >= 1.0)) call my_stop("x_flap must be < 1.")
  if ((use_flap) .and. (y_flap_spec /= 'y/c') .and. (y_flap_spec /= 'y/t'))    &
    call my_stop("y_flap_spec must be 'y/c' or 'y/t'.")

  if ((y_flap_spec  /= 'y/c') .and. (y_flap_spec  /= 'y/t')) &
    call my_stop ("Vertical hinge definition must be 'y/c' or 'y/t'")



  do i = 1, noppoint

    op  = op_points_spec(i) 

    if (op%re%number <= 0.d0) &
      call my_op_stop (i,op_points_spec, "reynolds must be > 0. Default value (re_default) could not be set")
    if (op%ma%number < 0.d0) &
      call my_op_stop (i,op_points_spec, "mach must be >= 0.")
    if (op%weighting_user <= 0.d0) &
      call my_op_stop (i,op_points_spec, "weighting must be > 0.")
    if (trim(op%optimization_type) /= 'min-drag' .and.                         &
      trim(op%optimization_type) /= 'max-glide' .and.                          &
      trim(op%optimization_type) /= 'min-sink' .and.                           &
      trim(op%optimization_type) /= 'max-lift' .and.                           &
      trim(op%optimization_type) /= 'target-moment' .and.                      &
      trim(op%optimization_type) /= 'target-drag' .and.                        &
      trim(op%optimization_type) /= 'target-lift' .and.                        &
      trim(op%optimization_type) /= 'target-glide' .and.                        &
      trim(op%optimization_type) /= 'max-xtr' .and.                            &
      trim(op%optimization_type) /= 'min-lift-slope' .and.                     &
      trim(op%optimization_type) /= 'min-glide-slope' .and.                    &
      trim(op%optimization_type) /= 'max-lift-slope')                          &
      call my_op_stop (i,op_points_spec, "optimization_type must be 'min-drag', 'max-glide', "//     &
                   "'min-sink', 'max-lift', 'max-xtr', 'target-moment', "//    &
                   "'target-drag', 'target-glide', 'min-lift-slope', 'min-glide-slope'"//      &
                   " or 'max-lift-slope'.")
    if ((trim(op%optimization_type) == 'max-lift-slope') .and. (noppoint == 1))&
      call my_op_stop (i,op_points_spec, "at least two operating points are required for to "//      &
                   "maximize lift curve slope.")
    if ((trim(op%optimization_type) == 'min-lift-slope') .and. (noppoint == 1))&
      call my_op_stop (i,op_points_spec, "at least two, better three operating points are required"//&
                   " for to minimize lift curve slope.")
    if ((trim(op%optimization_type) == 'min-glide-slope') .and. (noppoint == 1))&
      call my_op_stop (i,op_points_spec, "at least two, better three operating points are required"//&
                   " for to minimize lift curve slope.")
    if ((op%ncrit <= 0.d0) .and. (op%ncrit /= -1d0)) &
      call my_op_stop (i,op_points_spec, "ncrit_pt must be > 0 or -1.")

    if (((trim(op%optimization_type) == 'target-moment') .and.                &
        (target_value(i)) == -1.d3) )                                         &
      call my_op_stop (i,op_points_spec, "No 'target-value' defined for "//  &
                 "for optimization_type 'target-moment'")
    if (((trim(op%optimization_type) == 'target-drag') .and.                  &
        (target_value(i)) == -1.d3) )                                         &
      call my_op_stop (i,op_points_spec, "No 'target-value' defined for "//  &
                     "for optimization_type 'target-drag'")
    if (((trim(op%optimization_type) == 'target-glide') .and.                 &
        (target_value(i)) == -1.d3) )                                         &
      call my_op_stop (i,op_points_spec, "No 'target-value' defined for "//  &
                     "for optimization_type 'target-glide'")
    if (((trim(op%optimization_type) == 'target-lift') .and.                  &
        (target_value(i)) == -1.d3) )                                         &
      call my_op_stop (i,op_points_spec, "No 'target-value' defined for "//  &
                     "for optimization_type 'target-lift'")

    if (abs(flap_degrees(i)) > 70d0) &
      call my_stop ('Flap angle must be less than 70 degrees')
    if ((flap_selection(i) /= 'specify') .and. (flap_selection(i) /= 'optimize')) then
      call my_stop ("Flap selection must be 'spcify' or 'optimize')")
    end if 

  end do

end subroutine read_op_points_spec



!=============================================================================
! Read xoptfoil input file for bezier options 
!=============================================================================

subroutine read_bezier_inputs  (input_file, or_iunit, bezier_spec)
  !! read input file for bezier curve options 

  use airfoil_shape_bezier,  only : bezier_spec_type

  character(*), intent(in) :: input_file
  integer, intent(in)      :: or_iunit
  type(bezier_spec_type), intent(out) :: bezier_spec

  integer :: ncpoints_top, ncpoints_bot
  integer :: iunit, ioerr, iostat1

  namelist /bezier_options/ ncpoints_top, ncpoints_bot

! Init default values 

  ncpoints_top = 6    
  ncpoints_bot = 6    
  
! Open input file and read namelist from file

  if (trim(input_file) == '') then
    iunit = or_iunit
    rewind(iunit)
    read(iunit, iostat=iostat1, nml=bezier_options)
  else
    iunit = 12
    open(unit=iunit, file=input_file, status='old', iostat=ioerr)
    if (ioerr == 0) then
      read(iunit, iostat=iostat1, nml=bezier_options)
      close(iunit)
    end if
  end if
  
! Put options into derived types

  if (ncpoints_top < 3 .or. ncpoints_top > 10) &
    call my_stop("Number of Bezier control points must be >= 3 and <= 10.")
  if (ncpoints_bot < 3 .or. ncpoints_bot > 10) &
    call my_stop("Number of Bezier control points must be >= 3 and <= 10.")

  bezier_spec%ncpoints_top = ncpoints_top
  bezier_spec%ncpoints_bot = ncpoints_bot

  allocate (bezier_spec%px_top(ncpoints_top))
  allocate (bezier_spec%py_top(ncpoints_top))
  allocate (bezier_spec%px_bot(ncpoints_bot))
  allocate (bezier_spec%py_bot(ncpoints_bot))
  bezier_spec%px_top = 0d0
  bezier_spec%py_top = 0d0
  bezier_spec%px_bot = 0d0
  bezier_spec%py_bot = 0d0
  
end subroutine read_bezier_inputs



!=============================================================================
! Read xoptfoil input file to get flap setting options
!=============================================================================

subroutine read_flap_inputs  (input_file, or_iunit, flap_spec) 

  use vardef,             only : flap_spec_type

  character(*), intent(in)      :: input_file
  integer, intent(in)           :: or_iunit
  type(flap_spec_type), intent(out) :: flap_spec


  double precision, dimension(size(flap_spec%degrees)) :: flap_degrees
  double precision               :: x_flap, y_flap
  character(3)                   :: y_flap_spec
  integer                        :: iostat1, iunit, i, ioerr, ndegrees
  logical                        :: use_flap

  namelist /operating_conditions/ use_flap, x_flap, y_flap, y_flap_spec, &
                                  flap_degrees

  ! Init default values 

  use_flap     = .false.                
  x_flap       = 0.75d0
  y_flap       = 0.d0
  y_flap_spec  = 'y/c'

  flap_degrees      = 0d0

  ! Open input file and read namelist from file

  if (trim(input_file) == '') then
    iunit = or_iunit
    rewind(iunit)
    read(iunit, iostat=iostat1, nml=operating_conditions)
  else
    iunit = 12
    open(unit=iunit, file=input_file, status='old', iostat=ioerr)
    if (ioerr /= 0) call my_stop('Could not find input file '//trim(input_file)//'.')
    read(iunit, iostat=iostat1, nml=operating_conditions)
    close(iunit)
  end if

  ! All parms optional - so no warning call namelist_check ...

  ! Check Input 

  if ((use_flap) .and. (x_flap <= 0.0)) call my_stop("x_flap must be > 0.")
  if ((use_flap) .and. (x_flap >= 1.0)) call my_stop("x_flap must be < 1.")
  if ((use_flap) .and. (y_flap_spec /= 'y/c') .and. (y_flap_spec /= 'y/t'))    &
    call my_stop("y_flap_spec must be 'y/c' or 'y/t'.")

  if ((y_flap_spec  /= 'y/c') .and. (y_flap_spec  /= 'y/t')) &
    call my_stop ("Vertical hinge definition must be 'y/c' or 'y/t'")
  do i = 1, size(flap_degrees)
    if (abs(flap_degrees(i)) > 70d0) &
      call my_stop ('Flap angle must be less than 70 degrees')
  end do

  ndegrees = 0

  do i = size(flap_degrees), 1, -1
    if (flap_degrees(i) /= 0d0) then
      ndegrees = i
      exit
    end if
  end do

  flap_spec%use_flap    = use_flap
  flap_spec%x_flap      = x_flap
  flap_spec%y_flap      = y_flap
  flap_spec%y_flap_spec = y_flap_spec
  flap_spec%ndegrees    = ndegrees

  if (ndegrees == 0) then 
    flap_spec%use_flap    = .false.
    flap_spec%degrees     = 0d0
  else
    flap_spec%use_flap    = use_flap
    flap_spec%degrees     = flap_degrees
  end if 


end subroutine read_flap_inputs


!-----------------------------------------------------------------------------
! Stops execution when there is an invalid op_point paramter
!-----------------------------------------------------------------------------

subroutine my_op_stop (iop, op_points_spec, message)

  use xfoil_driver,       only : op_point_specification_type

  type(op_point_specification_type), dimension(:), allocatable, intent(in)  :: op_points_spec
  integer, intent (in)      :: iop
  character(*), intent(in)  :: message
  character(20)             :: op_string

  write (op_string, '(I2)') iop
  op_string = 'Op_point '// adjustl(trim(op_string)) 

  call echo_op_points_spec  (op_points_spec)

  call my_stop (trim(op_string) //': '// message)

end subroutine my_op_stop


!-----------------------------------------------------------------------------
! Echo input parms of operating points entered by user
!-----------------------------------------------------------------------------

subroutine echo_op_points_spec  (op_points_spec, xfoil_options)

  use xfoil_driver,       only : op_point_specification_type
  use xfoil_driver,       only : xfoil_options_type

  type(op_point_specification_type), dimension(:), intent(in)  :: op_points_spec
  type(xfoil_options_type), intent(in), optional  :: xfoil_options

  integer               :: i, re_int
  character(10)         :: spec_char, target_value_char, ncrit_char, dynamic_char
  type(op_point_specification_type) :: op


  !write (*,'(" - ",A)') 'Echo operating point definitions'
  write (*,*) 
  write (*,'(" - ",A2,":",A7,A6,A15,A9,A10,A5,A7,A15)') &
                'No', 'Spec', 'Point', 'Opt. Type', ' Target', & 
                'Re', 'Type', 'ncrit', 'Weighting'
  
  do i = 1, size (op_points_spec)

    op = op_points_spec(i)

    if (op%spec_cl) then
      spec_char = 'cl'
    else
      spec_char = 'alpha'
    end if

    if (op%target_value == -1.d3 ) then 
      target_value_char = '-'
    elseif (op%target_value >= 10d0 ) then 
      write (target_value_char,'(F9.2)') op%target_value
    else
      write (target_value_char,'(F9.5)') op%target_value
    end if

    if (op%ncrit == -1.d0 ) then 
      if ( present(xfoil_options)) then
        write (ncrit_char,'(F7.1)') xfoil_options%ncrit
      else
        ncrit_char = '-'
      end if 
    else
      write (ncrit_char,'(F7.1)') op%ncrit
    end if

    if (op%dynamic_weighting) then 
      dynamic_char = 'dynamic'
    else
      dynamic_char = ''
    end if

    re_int = int (op%re%number)

    write (*,'(3x,I2,":",A7,F6.2,A15,A9,I10,I5,A7,F11.2, 1x,A7)') &
          i, trim(spec_char), op%value, trim(op%optimization_type), trim(target_value_char), &
          re_int, op%re%type, trim(ncrit_char), op%weighting_user, trim(dynamic_char)
  end do 

  write (*,*)

end subroutine echo_op_points_spec


!=============================================================================
! Read xoptfoil input file to geometric constraints
!=============================================================================

subroutine read_curvature_constraints_inputs  (input_file, or_iunit, &
                                          curv_spec, curv_top_spec, curv_bot_spec)

  use vardef, only             : NOT_DEF_D, NOT_DEF_I
  use airfoil_evaluation, only : curvature_specification_type, curvature_polyline_specification_type

  character(*), intent(in)           :: input_file
  integer, intent(in)                :: or_iunit
  type (curvature_specification_type),  intent(inout) :: curv_spec
  type (curvature_polyline_specification_type), intent(inout) :: curv_top_spec
  type (curvature_polyline_specification_type), intent(inout) :: curv_bot_spec

  type (curvature_polyline_specification_type) :: spec

  integer :: iostat1, iunit, ioerr
  integer :: max_curv_reverse_top, max_curv_reverse_bot
  double precision  :: max_te_curvature
  double precision  :: curv_threshold, spike_threshold
  logical :: check_curvature, auto_curvature, do_smoothing

! #depricated
  integer :: max_curv_highlow_top, max_curv_highlow_bot
  integer :: max_spikes_top, max_spikes_bot
  doubleprecision :: highlow_threshold

  namelist /curvature  / check_curvature, auto_curvature, do_smoothing, &
                         highlow_threshold, spike_threshold, curv_threshold, &
                         max_te_curvature, &
                         max_curv_reverse_top, max_curv_reverse_bot,  &
                         max_curv_highlow_top, max_curv_highlow_bot, &
                         max_spikes_top, max_spikes_bot, &
                         curv_top_spec, curv_bot_spec


! Default values for curvature parameters

  do_smoothing         = .false.              ! now default - smoothing will be forced if 
                                              !               quality of surface is bad
  check_curvature      = .true.
  auto_curvature       = .true.
  max_te_curvature     = 10.d0                ! more or less inactive by default
  max_curv_reverse_top = 0
  max_curv_reverse_bot = 0
  max_spikes_top       = 0
  max_spikes_bot       = 0
  curv_threshold       = 0.1d0
  spike_threshold      = 0.4d0

  highlow_threshold    = NOT_DEF_D            ! #depricated
  max_curv_highlow_top = NOT_DEF_I            ! #depricated
  max_curv_highlow_bot = NOT_DEF_I            ! #depricated

  ! Set final top and bot data structure to "undefined" 
  ! - to detect user overwrite in input file (Expert mode) 

  spec%check_curvature_bumps = .false.
  spec%max_te_curvature = NOT_DEF_D
  spec%max_curv_reverse = NOT_DEF_I
  spec%max_spikes       = NOT_DEF_I
  spec%curv_threshold   = NOT_DEF_D
  spec%spike_threshold  = NOT_DEF_D

  curv_top_spec = spec
  curv_bot_spec = spec

  
  ! Open input file and read namelist from file

  if (trim(input_file) == '' .and. or_iunit > 0 ) then
    iunit = or_iunit
    rewind(iunit)
    read(iunit, iostat=iostat1, nml=curvature)
  elseif (trim(input_file) /= '') then
    iunit = 12
    open(unit=iunit, file=input_file, status='old', iostat=ioerr)
    if (ioerr == 0) then
      read(iunit, iostat=iostat1, nml=curvature)
      close(iunit)
    else
      iostat1 = ioerr 
    end if
  else
    iostat1 = 0 
  end if
  call namelist_check('curvature', iostat1, 'no-warn')

  if (max_curv_highlow_top /= NOT_DEF_I) & 
    call print_note ("'max_curv_highlow_top' is deprecated and won't be considered") 
  if (max_curv_highlow_bot /= NOT_DEF_I) & 
    call print_note ("'max_curv_highlow_bot' is deprecated and won't be considered") 
  if (highlow_threshold    /= NOT_DEF_D) & 
    call print_note ("'highlow_threshold' is deprecated and won't be considered") 

  curv_spec%check_curvature      = check_curvature
  curv_spec%auto_curvature       = auto_curvature
  curv_spec%do_smoothing         = do_smoothing

! Allow user input of detailed internal structures  

  spec = curv_top_spec

  if (spec%max_te_curvature == NOT_DEF_D) spec%max_te_curvature = max_te_curvature
  if (spec%max_curv_reverse == NOT_DEF_I) spec%max_curv_reverse = max_curv_reverse_top
  if (spec%max_spikes       == NOT_DEF_I) spec%max_spikes       = max_spikes_top
  if (spec%curv_threshold   == NOT_DEF_D) spec%curv_threshold   = curv_threshold
  if (spec%spike_threshold  == NOT_DEF_D) spec%spike_threshold  = spike_threshold

  curv_top_spec = spec 

  spec = curv_bot_spec

  if (spec%max_te_curvature == NOT_DEF_D) spec%max_te_curvature = max_te_curvature
  if (spec%max_curv_reverse == NOT_DEF_I) spec%max_curv_reverse = max_curv_reverse_bot
  if (spec%max_spikes       == NOT_DEF_I) spec%max_spikes       = max_spikes_bot
  if (spec%curv_threshold   == NOT_DEF_D) spec%curv_threshold   = curv_threshold
  if (spec%spike_threshold  == NOT_DEF_D) spec%spike_threshold  = spike_threshold

  curv_bot_spec = spec 

end subroutine read_curvature_constraints_inputs


!=============================================================================
! Read xoptfoil input file to xfoil_paneling_options
!   (separated from read_inputs to be more modular)
!=============================================================================

subroutine read_xfoil_paneling_inputs  (input_file, or_iunit, geom_options)

  use vardef,             only : npan_fixed
  use xfoil_driver,       only : xfoil_geom_options_type

  character(*), intent(in) :: input_file
  integer, intent(in)      :: or_iunit
  type(xfoil_geom_options_type), intent(out) :: geom_options
  double precision :: cvpar, cterat, ctrrat, xsref1, xsref2, xpref1, xpref2

  integer :: npan
  integer :: iostat1, iunit, ioerr
  logical :: repanel

  namelist /xfoil_paneling_options/ npan, cvpar, cterat, ctrrat, xsref1,       &
            xsref2, xpref1, xpref2

  ! Init default values for xfoil options

  if (npan_fixed > 0) then 
    npan   = npan_fixed     ! if npan_fixed is set - this is the one
  else             
    npan   = 200            ! a real default
  end if             

  cvpar  = 1.d0
  cterat = 0.0d0            ! if set to normal value 0.15d0, the curvature calc at TE panel
                            !   tends to flip away and have tripple value (bug in xfoil) 
  ctrrat = 0.2d0
  xsref1 = 1.d0
  xsref2 = 1.d0
  xpref1 = 1.d0
  xpref2 = 1.d0

  repanel = .false.          ! repanel for each design before running xfoil

  
! Open input file and read namelist from file

  if (trim(input_file) == '') then
    iunit = or_iunit
    rewind(iunit)
    read(iunit, iostat=iostat1, nml=xfoil_paneling_options)
  else
    iunit = 12
    open(unit=iunit, file=input_file, status='old', iostat=ioerr)
    if (ioerr == 0) then
      read(iunit, iostat=iostat1, nml=xfoil_paneling_options)
      close(iunit)
    end if
  end if
  
! Put xfoil options into derived types

  if (npan_fixed > 0 .and. (npan /= npan_fixed)) then 
    npan = npan_fixed 
    call print_note ("Number of panels (npan) is fixed for optimizations and can't be changed")
  end if 

  if (npan < 20) call my_stop("npan must be >= 20.")
  if (cvpar <= 0.d0) call my_stop("cvpar must be > 0.")
  if (cterat < 0.d0) call my_stop("cterat must be >= 0.")
  if (ctrrat <= 0.d0) call my_stop("ctrrat must be > 0.")
  if (xsref1 < 0.d0) call my_stop("xsref1 must be >= 0.")
  if (xsref2 < xsref1) call my_stop("xsref2 must be >= xsref1")
  if (xsref2 > 1.d0) call my_stop("xsref2 must be <= 1.")
  if (xpref1 < 0.d0) call my_stop("xpref1 must be >= 0.")
  if (xpref2 < xpref1) call my_stop("xpref2 must be >= xpref1")
  if (xpref2 > 1.d0) call my_stop("xpref2 must be <= 1.")


  geom_options%repanel = repanel
  geom_options%npan   = npan
  geom_options%cvpar  = cvpar
  geom_options%cterat = cterat
  geom_options%ctrrat = ctrrat
  geom_options%xsref1 = xsref1
  geom_options%xsref2 = xsref2
  geom_options%xpref1 = xpref1
  geom_options%xpref2 = xpref2

end subroutine read_xfoil_paneling_inputs



!=============================================================================
! Read xfoil_run_options input
!=============================================================================

subroutine read_xfoil_options_inputs  (input_file, or_iunit, xfoil_options)

  use xfoil_driver, only : xfoil_options_type

  character(*), intent(in) :: input_file 
  integer, intent(in)      :: or_iunit
  type(xfoil_options_type), intent(out)    :: xfoil_options

  logical :: viscous_mode, silent_mode, fix_unconverged, reinitialize, show_details
  integer :: bl_maxit
  double precision :: ncrit, xtript, xtripb, vaccel
  integer :: iunit, ioerr, iostat1

  namelist /xfoil_run_options/ ncrit, xtript, xtripb, viscous_mode,            &
  silent_mode, bl_maxit, vaccel, fix_unconverged, reinitialize, show_details


  ! Set default xfoil aerodynamics

  ncrit = 9.d0
  xtript = 1.d0
  xtripb = 1.d0
  viscous_mode = .true.
  silent_mode = .true.
  bl_maxit = 50             ! reduced to 50 as above the potential result is rarely usable..
  vaccel = 0.005d0          ! the original value of 0.01 leads to too many non convergences at 
                            !   higher lift --> reduced 
  fix_unconverged = .true.
  reinitialize = .false.    ! as run_xfoil is improved, this will speed up the xfoil calcs
  show_details = .false.    ! show success info during op point calculation

! Read xfoil options

  if (trim(input_file) == '') then
    iunit = or_iunit
    rewind(iunit)
    read(iunit, iostat=iostat1, nml=xfoil_run_options)
  else
    iunit = 12
    open(unit=iunit, file=input_file, status='old', iostat=ioerr)
    if (ioerr == 0) then
      read(iunit, iostat=iostat1, nml=xfoil_run_options)
      close(iunit)
    end if
  end if

  call namelist_check ('xfoil_run_options', iostat1, 'no-warn')
! XFoil run options

  if (ncrit < 0.d0) call my_stop("ncrit must be >= 0.")
  if (xtript < 0.d0 .or. xtript > 1.d0)                                        &
    call my_stop("xtript must be >= 0. and <= 1.")
  if (xtripb < 0.d0 .or. xtripb > 1.d0)                                        &
    call my_stop("xtripb must be >= 0. and <= 1.")
  if (bl_maxit < 1) call my_stop("bl_maxit must be > 0.")
  if (vaccel < 0.d0) call my_stop("vaccel must be >= 0.")


  ! Put xfoil options into derived types

  xfoil_options%ncrit = ncrit
  xfoil_options%xtript = xtript
  xfoil_options%xtripb = xtripb
  xfoil_options%viscous_mode = viscous_mode
  xfoil_options%silent_mode = silent_mode
  xfoil_options%maxit = bl_maxit
  xfoil_options%vaccel = vaccel
  xfoil_options%fix_unconverged = fix_unconverged
  xfoil_options%exit_if_unconverged = .false.
  xfoil_options%detect_outlier = .true.
  xfoil_options%reinitialize = reinitialize
  xfoil_options%show_details = show_details

end subroutine read_xfoil_options_inputs

!-----------------------------------------------------------------------------
! Echo xfoil_run_options input
!-----------------------------------------------------------------------------

subroutine echo_xfoil_options_inputs  (xfoil_options)

  use xfoil_driver, only : xfoil_options_type
  type(xfoil_options_type), intent(out)    :: xfoil_options

  write(*,'(A)') " &xfoil_run_options"
  write(*,*) " ncrit = ", xfoil_options%ncrit
  write(*,*) " xtript = ", xfoil_options%xtript
  write(*,*) " xtripb = ", xfoil_options%xtripb
  write(*,*) " viscous_mode = ", xfoil_options%viscous_mode
  write(*,*) " silent_mode = ", xfoil_options%silent_mode
  write(*,*) " bl_maxit = ", xfoil_options%maxit
  write(*,*) " vaccel = ", xfoil_options%vaccel
  write(*,*) " fix_unconverged = ", xfoil_options%fix_unconverged
  write(*,*) " reinitialize = ", xfoil_options%reinitialize
  write(*,'(A)') " /"
  write(*,*)

end subroutine 

!=============================================================================80
!
! Prints error and stops or warns for bad namelist read
!
!=============================================================================80
subroutine namelist_check(nmlname, errcode, action_missing_nml)

  character(*), intent(in) :: nmlname
  integer, intent(in) :: errcode
  character(*), intent(in) :: action_missing_nml

  character (20) :: out_string

  if (errcode < 0) then
    if (trim(action_missing_nml) == 'warn') then
      call print_note ("Namelist '"//trim(nmlname)//& 
                      "' not found in input file. Using default values.")
    elseif (trim(action_missing_nml) == 'no-warn') then
      ! do nothing
    else
      call my_stop ('Namelist '//trim(nmlname)//' is required and was not found in input file.')
    end if

  else if (errcode == 2) then
    if (trim(action_missing_nml) == 'warn') then
      call print_note ('No input file. Using default values for namelist '// trim(nmlname))
    elseif (trim(action_missing_nml) == 'no-warn') then
      ! do nothing
    else
      call my_stop ('No input file. Namelist '//trim(nmlname)//' is required for operation.')
    end if

  else if (errcode > 0) then
    write (out_string,'(I5)') errcode
    out_string = ' (err='//trim(adjustl(out_string))//')'
    call my_stop ('Unrecognized variable in namelist '//trim(nmlname)//trim(out_string))
  else
    continue
  end if

end subroutine namelist_check

!=============================================================================80
!
! Reads command line arguments for input file name and output file prefix
!
!=============================================================================80
subroutine read_clo(input_file, output_prefix, exename)

  character(:), allocatable, intent(inout) :: input_file, output_prefix
  character(*), intent(in), optional :: exename

  character(100) :: arg, exeprint
  integer i, nargs
  logical getting_args

  if (present(exename)) then
    exeprint = exename
  else
    exeprint = "xoptfoil"
  end if 

  nargs = iargc()
  if (nargs > 0) then
    getting_args = .true.
  else
    getting_args = .false.
  end if

  i = 1
  do while (getting_args)
    call getarg(i, arg) 

    if (trim(arg) == "-i") then
      if (i == nargs) then
        call my_stop("Must specify an input file with -i option.")
      else
        call getarg(i+1, arg)
        input_file = trim(arg) 
        i = i+2
      end if

    else if (trim(arg) == "-o") then
      if (i == nargs) then
        call my_stop("Must specify an output prefix with -o option.")
      else
        call getarg(i+1, arg)
        output_prefix = trim(arg) 
        i = i+2
      end if

    else if (trim(arg) == "-r") then
      if (i == nargs) then
        call my_stop("Must specify a re value for -r option.")
      else
        call getarg(i+1, arg)
        i = i+2
      end if

    else if (trim(arg) == "-a") then
      if (i == nargs) then
        call my_stop("Must specify filename of seed airfoil for -a option.")
      else
        call getarg(i+1, arg)
        i = i+2
      end if

    else if ( (trim(arg) == "-h") .or. (trim(arg) == "--help") ) then
      call print_usage(exeprint)
      stop

    else
      call print_error ("Unrecognized option "//trim(arg)//".")
      call print_usage (exeprint)
      stop 1
    end if

    if (i > nargs) getting_args = .false.
  end do

end subroutine read_clo


!=============================================================================80
!
! Prints usage information
!
!=============================================================================80
subroutine print_usage(exeprint)

  character(*), intent(in) :: exeprint

  write(*,'(A)') 
  write(*,'(A)') '         (c) 2017-2019 Daniel Prosser (original Xoptfoil)'
  write(*,'(A)') '         (c) 2019-2023 Jochen Guenzel, Matthias Boese'
  write(*,'(A)')
  write(*,'(A)') "Usage: "//trim(exeprint)//" [OPTION]"
  write(*,'(A)')
  write(*,'(A)') "Options:"
  write(*,'(A)') "  -i input_file     Specify a non-default input file"
  write(*,'(A)') "  -o output_prefix  Specify a non-default output prefix"
  write(*,'(A)') "  -r xxxxxx         Specify a default reynolds number (re_default)"
  write(*,'(A)') "  -a airfoil_file   Specify filename of seed airfoil"
  write(*,'(A)') "  -h, --help        Display usage information and exit"
  write(*,'(A)')
  write(*,'(A)') "Refer to the Xoptfoil    user guide and" 
  write(*,'(A)') "             Xoptfoil-JX reference guide for further help."
  write(*,'(A)')
  write(*,'(A)') "Development page: https://github.com/jxjo/Xoptfoil"
  write(*,'(A)') "Report bugs using the issue reporting system "
  write(*,'(A)')

end subroutine print_usage



! jx-mod -----------------------------------------------------------------
! Reads command line argument -r for default reynolds number
! ------------------------------------------------------------------------

function read_cl_re_default (re_default)

  double precision, intent(in) :: re_default
  double precision :: read_cl_re_default

  character(80) :: arg, re_as_char
  integer i, nargs
  logical getting_args

  read_cl_re_default = re_default

  nargs = iargc()
  if (nargs > 0) then
    getting_args = .true.
  else
    getting_args = .false.
  end if

  i = 1
  do while (getting_args)
    call getarg(i, arg) 

    if (trim(arg) == "-r") then
      if (i == nargs) then
        call my_stop("Must specify a reynolds number with -r option.")
      else
        call getarg(i+1, re_as_char)
        read (re_as_char,*) read_cl_re_default
        if (read_cl_re_default == 0d0)     &
           call my_stop("-r option has no valid reynolds numer")
        exit 
      end if
    end if
    i = i + 1
    if (i > nargs) getting_args = .false.
  end do

end function read_cl_re_default

! jx-mod -----------------------------------------------------------------
! Reads command line argument -a for seed airfoil
! ------------------------------------------------------------------------

function read_cl_airfoil_file (file_name)

  character(80), intent(in) :: file_name
  character(80) :: read_cl_airfoil_file

  character(80) :: arg
  integer i, nargs
  logical getting_args

  read_cl_airfoil_file = file_name

  nargs = iargc()
  if (nargs > 0) then
    getting_args = .true.
  else
    getting_args = .false.
  end if

  i = 1
  do while (getting_args)
    call getarg(i, arg) 

    if (trim(arg) == "-a") then
      if (i == nargs) then
        call my_stop("Must specify a airfoil filename with -a option.")
      else
        call getarg(i+1, arg)
        read_cl_airfoil_file = arg
      end if
    end if
    i = i + 1
    if (i > nargs) getting_args = .false.
  end do

end function read_cl_airfoil_file

end module input_output
